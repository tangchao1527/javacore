一、类加载流程
   之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，
   将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，
   而是否能够运行则由 Execution Engine 来决定

   2.1 类加载器的流程
   从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中验证，准备，解析三个部分统称为连接

   2.1.1 加载
   将class文件加载到内存
   将静态数据结构转化成方法区中运行时的数据结构
   在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口

   2.1.2 链接
   验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查
   准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3
   （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）
   解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）

   2.1.3 初始化
   初始化其实就是一个赋值的操作，它会执行一个类构造器的<clinit>()方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3

   2.1.4 卸载
   GC将无用对象从内存中卸载

   2.2 类加载器的加载顺序
   加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的

   BootStrap ClassLoader：rt.jar

   Extention ClassLoader: 加载扩展的jar包

   App ClassLoader：指定的classpath下面的jar包

   Custom ClassLoader：自定义的类加载器

   2.3 双亲委派机制
   当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个Person，
   这个Person是我们自定义的类，如果我们要加载它，就会先委派App ClassLoader，只有当父类加载器都反馈自己无法完成这个请求
   （也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载
   这样做的好处是，加载位于rt.jar包中的类时不管是哪个加载器加载，最终都会委托到BootStrap ClassLoader进行加载，
   这样保证了使用不同的类加载器得到的都是同一个结果。
   其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个
   public class String(){
       public static void main(){sout;}
   }
   这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了rt.jar中的String.class，然后发现这也没有main方法

