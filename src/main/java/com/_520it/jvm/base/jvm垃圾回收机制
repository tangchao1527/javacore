一，什么是垃圾对象？
   为了确定哪些对象是垃圾，jvm为我们提供了一些算法去判定。常见的判断是否存活有两种方法：引用计数法和可达性分析。

二，引入计数法
   为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。
   每当有一个地方去引用它时候，引用计数器就增加1。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，
   它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。
   缺点：两个类相互是对方的成员变量，toString的时候，相互调用。造成循环引用。因此，Java 里没有采用这样的方案来判定对象的“存活性”。

三，可达性分析

   可达性分析基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，
   或称“存活”对象。不能到达的则被可回收对象。

   GC Roots 本身是一个出发点，也就是说我们每次进行可达性分析的时候都要从这个初始点出发。换句话说，初始点我们一定是可达的。
   那么，Java 里有哪些对象可以作为GC Roots呢？主要有以下四种：
   虚拟机栈（帧栈中的本地变量表）中引用的对象。
   方法区中静态属性引用的对象。
   方法区中常量引用的对象。
   本地方法栈中 JNI 引用的对象。

四，常用的垃圾回收算法？

   a、标记－清理
     第一步（标记），利用可达性遍历内存，把“存活”对象和“垃圾”对象进行标记。第二步（清理），我们再遍历一遍，
     把所有“垃圾”对象所占的空间直接 清空 即可。
     特点：
     简单方便
     容易产生内存碎片
   b、标记－整理
     上面的方法我们发现会产生内存碎片，因此在这个方法中同样为两步：
     第一步（标记）：利用可达性遍历内存，把“存活”对象和“垃圾”对象进行标记。
     第二步（整理）：把所有存活对象堆到同一个地方，这样就没有内存碎片了。
     特点：
     适合存活对象多，垃圾少的情况
     需要整理的过程
   c、复制算法
     将内存按照容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完了，
     就将还活着的对象复制到另一块上，然后再把使用过的内存空间一次性清理掉
     特点：
     简单
     不会产生碎片
     内存利用率太低，只用了一半
   d、分代收集算法
     这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，
     这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，
     那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，
     就必须使用“标记-清理”或者“标记-整理”算法来进行回收。

五、堆的内存划分
    Java堆的内存划分，分别为年轻代、Old Memory（老年代）、Perm（永久代）。其中在Jdk1.8中，永久代被移除，使用MetaSpace代替。
    1、新生代：
    （1）使用复制清除算法（Copinng算法），原因是年轻代每次GC都要回收大部分对象。新生代里面分成一份较大的Eden空间和两份较小的Survivor空间。
        每次只使用Eden和其中一块Survivor空间，然后垃圾回收的时候，把存活对象放到未使用的Survivor（划分出from、to）空间中，清空Eden和刚才使用过的Survivor空间。
    （2）分为Eden、Survivor From、Survivor To，比例默认为8：1：1
    （3）内存不足时发生Minor GC
    2、老年代：
    （1）采用标记-整理算法（mark-compact），原因是老年代每次GC只会回收少部分对象。
    3、Perm：用来存储类的元数据，也就是方法区。
    （1）Perm的废除：在jdk1.8中，Perm被替换成MetaSpace，MetaSpace存放在本地内存中。原因是永久代进场内存不够用，或者发生内存泄漏。
    （2）MetaSpace（元空间）：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟

六、GC垃圾回收
    一、 判断对象是否要回收的方法：可达性分析法
    1、 可达性分析法：通过一系列“GC Roots”对象作为起点进行搜索，如果在“GC Roots”和一个对象之间没有可达路径，则称该对象是不可达的。不可达对象不一定会成为可回收对象。进入DEAD状态的线程还可以恢复，GC不会回收它的内存。（把一些对象当做root对象，JVM认为root对象是不可回收的，并且root对象引用的对象也是不可回收的）
    2、 以下对象会被认为是root对象：
    （1） 虚拟机栈（栈帧中本地变量表）中引用的对象
    （2） 方法区中静态属性引用的对象
    （3） 方法区中常量引用的对象
    （4） 本地方法栈中Native方法引用的对象
    3、 对象被判定可被回收，需要经历两个阶段：
    （1） 第一个阶段是可达性分析，分析该对象是否可达
    （2） 第二个阶段是当对象没有重写finalize()方法或者finalize()方法已经被调用过，虚拟机认为该对象不可以被救活，因此回收该对象。（finalize()方法在垃圾回收中的作用是，给该对象一次救活的机会）
    4、 方法区中的垃圾回收：
    （1） 常量池中一些常量、符号引用没有被引用，则会被清理出常量池
    （2） 无用的类：被判定为无用的类，会被清理出方法区。判定方法如下：
    A、 该类的所有实例被回收
    B、 加载该类的ClassLoader被回收
    C、 该类的Class对象没有被引用
    5、 finalize():
    （1） GC垃圾回收要回收一个对象的时候，调用该对象的finalize()方法。然后在下一次垃圾回收的时候，才去回收这个对象的内存。
    （2） 可以在该方法里面，指定一些对象在释放前必须执行的操作。

    二、 发现虚拟机频繁full GC时应该怎么办：
    （full GC指的是清理整个堆空间，包括年轻代和永久代）
    （1） 首先用命令查看触发GC的原因是什么 jstat –gccause 进程id
    （2） 如果是System.gc()，则看下代码哪里调用了这个方法
    （3） 如果是heap inspection(内存检查)，可能是哪里执行jmap –histo[:live]命令
    （4） 如果是GC locker，可能是程序依赖的JNI库的原因

七、了解各种垃圾回收器

    收集器       串行、并行or并发        新生代/老年代       算法               目标                适用场景
    serial          串行                 新生代         复制算法          响应速度优先        单CPU环境的client模式
    serial old      串行                 老年代         标记整理          响应速度优先        单CPU Client模式，CMS后备预案
    parallel        并行                 新生代         复制算法          吞吐量优先          后台运行不需要太多交互的任务
    scavenger
    parallel old    并行                 老年代         标记整理          吞吐量优先          后台运行不需要太多交互的任务
    g1              并发                 both          标记整理+复制      响应速度优先        面向服务端应用，将来替换cms

备注：
   到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old
   从jdk9开始，G1收集器成为默认的垃圾收集器，目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。
   在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。
   G1回收器回收同样大小的新生代只停顿0.2秒。


